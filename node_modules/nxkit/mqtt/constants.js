"use strict";
/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2015, xuewen.chu
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of xuewen.chu nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL xuewen.chu BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */
Object.defineProperty(exports, "__esModule", { value: true });
/* Mnemonic => Command code */
/* Command code => mnemonic */
var types;
(function (types) {
    types[types["reserved"] = 0] = "reserved";
    types[types["connect"] = 1] = "connect";
    types[types["connack"] = 2] = "connack";
    types[types["publish"] = 3] = "publish";
    types[types["puback"] = 4] = "puback";
    types[types["pubrec"] = 5] = "pubrec";
    types[types["pubrel"] = 6] = "pubrel";
    types[types["pubcomp"] = 7] = "pubcomp";
    types[types["subscribe"] = 8] = "subscribe";
    types[types["suback"] = 9] = "suback";
    types[types["unsubscribe"] = 10] = "unsubscribe";
    types[types["unsuback"] = 11] = "unsuback";
    types[types["pingreq"] = 12] = "pingreq";
    types[types["pingresp"] = 13] = "pingresp";
    types[types["disconnect"] = 14] = "disconnect";
    types[types["reserve"] = 15] = "reserve";
})(types = exports.types || (exports.types = {}));
class CONSTANTS {
    constructor() {
        this.types = types;
        /* Header */
        this.CMD_SHIFT = 4;
        this.CMD_MASK = 0xF0;
        this.DUP_MASK = 0x08;
        this.QOS_MASK = 0x03;
        this.QOS_SHIFT = 1;
        this.RETAIN_MASK = 0x01;
        /* Length */
        this.LENGTH_MASK = 0x7F;
        this.LENGTH_FIN_MASK = 0x80;
        /* Connack */
        this.SESSIONPRESENT_MASK = 0x01;
        this.SESSIONPRESENT_HEADER = Buffer.from([this.SESSIONPRESENT_MASK]);
        this.CONNACK_HEADER = Buffer.from([types['connack'] << this.CMD_SHIFT]);
        /* Connect */
        this.USERNAME_MASK = 0x80;
        this.PASSWORD_MASK = 0x40;
        this.WILL_RETAIN_MASK = 0x20;
        this.WILL_QOS_MASK = 0x18;
        this.WILL_QOS_SHIFT = 3;
        this.WILL_FLAG_MASK = 0x04;
        this.CLEAN_SESSION_MASK = 0x02;
        this.CONNECT_HEADER = Buffer.from([types['connect'] << this.CMD_SHIFT]);
        /* Publish */
        this.PUBLISH_HEADER = this.genHeader('publish');
        /* Subscribe */
        this.SUBSCRIBE_HEADER = this.genHeader('subscribe');
        /* Unsubscribe */
        this.UNSUBSCRIBE_HEADER = this.genHeader('unsubscribe');
        /* Confirmations */
        this.ACKS = {
            unsuback: this.genHeader('unsuback'),
            puback: this.genHeader('puback'),
            pubcomp: this.genHeader('pubcomp'),
            pubrel: this.genHeader('pubrel'),
            pubrec: this.genHeader('pubrec')
        };
        this.SUBACK_HEADER = Buffer.from([types['suback'] << this.CMD_SHIFT]);
        /* Protocol versions */
        this.VERSION3 = Buffer.from([3]);
        this.VERSION4 = Buffer.from([4]);
        /* QoS */
        this.QOS = [0, 1, 2].map(function (qos) {
            return Buffer.from([qos]);
        });
        /* Empty packets */
        this.EMPTY = {
            pingreq: Buffer.from([types['pingreq'] << 4, 0]),
            pingresp: Buffer.from([types['pingresp'] << 4, 0]),
            disconnect: Buffer.from([types['disconnect'] << 4, 0])
        };
    }
    genHeader(type) {
        var self = this;
        return [0, 1, 2].map(function (qos) {
            return [0, 1].map(function (dup) {
                return [0, 1].map(function (retain) {
                    var buf = Buffer.alloc(1);
                    buf.writeUInt8(types[type] << self.CMD_SHIFT |
                        (dup ? self.DUP_MASK : 0) |
                        qos << self.QOS_SHIFT | retain, 0);
                    return buf;
                });
            });
        });
    }
}
exports.default = new CONSTANTS();
