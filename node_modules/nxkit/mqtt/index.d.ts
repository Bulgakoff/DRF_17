/// <reference types="node" />
import * as events from 'events';
import Store from './store';
import { Packet } from './parser';
export declare type Protocol = 'mqtt' | 'tcp' | 'mqtts' | 'ssl' | 'tls';
export interface CreateOptions {
    url?: string;
    keepalive?: number;
    reschedulePings?: boolean;
    protocolId?: string;
    protocolVersion?: number;
    reconnectPeriod?: number;
    connectTimeout?: number;
    clean?: boolean;
    resubscribe?: boolean;
    clientId?: string;
    outgoingStore?: Store;
    incomingStore?: Store;
    queueQoSZero?: boolean;
    protocol?: Protocol;
    port?: number;
    query?: any;
    auth?: string;
    username?: string;
    password?: string;
    cert?: string;
    key?: string;
    servers?: {
        host: string;
        port: number;
        protocol: Protocol;
    }[];
    host?: string;
    hostname?: string;
    rejectUnauthorized?: boolean;
}
export interface Options {
    qos?: number;
    dup?: false;
    retain?: boolean;
}
export interface SubscribeOptions extends Options {
    resubscribe?: any;
}
interface Callback {
    (e?: Error, data?: any): void;
}
declare function nop(): void;
/**
 * @class MqttClient
 */
export declare class MqttClient extends events.EventEmitter {
    readonly options: CreateOptions;
    private _reconnectCount;
    private _outgoingStore;
    private _incomingStore;
    private _queueQoSZero;
    private _resubscribeTopics;
    private _messageIdToTopic;
    private _pingTimer;
    private _queue;
    private _connackTimer;
    private _reconnectTimer;
    private _protocol;
    /**
     * MessageIDs starting with 1
     * ensure that nextId is min. 1, see https://github.com/mqttjs/MQTT.js/issues/810
     */
    private _nextId;
    private _outgoing;
    private _stream;
    private _deferredReconnect;
    private _pingResp;
    private _connected;
    private _disconnecting;
    private _disconnected;
    private _reconnecting;
    get connected(): boolean;
    get disconnecting(): boolean;
    get disconnected(): boolean;
    get reconnecting(): boolean;
    get nextId(): number;
    /**
     * MqttClient constructor
     *
     * @param {Object} [options] - connection options
     * (see Connection#connect)
     */
    constructor(options?: CreateOptions);
    private _flush;
    private __sendPacket;
    private _storeAndSend;
    /**
     * @func stream_builder()
     */
    private stream_builder;
    /**
     * setup the event handlers in the inner stream.
     *
     * @api private
     */
    private _setupStream;
    private _handlePacket;
    private _checkDisconnecting;
    /**
     * publish - publish <message> to <topic>
     *
     * @param {String} topic - topic to publish to
     * @param {String, Buffer} message - message to publish
     * @param {Object} [opts] - publish options, includes:
     *    {Number} qos - qos level to publish on
     *    {Boolean} retain - whether or not to retain the message
     *    {Boolean} dup - whether or not mark a message as duplicate
     * @param {Function} [callback] - function(err){}
     *    called when publish succeeds or fails
     * @returns {MqttClient} this - for chaining
     * @api public
     *
     * @example client.publish('topic', 'message');
     * @example
     *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});
     * @example client.publish('topic', 'message', console.log);
     */
    publish(topic: string, message?: string | Buffer, opts?: Options, callback?: Callback): this;
    /**
     * subscribe - subscribe to <topic>
     *
     * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}
     * @param {Object} [opts] - optional subscription options, includes:
     *    {Number} qos - subscribe qos level
     * @param {Function} [callback] - function(err, granted){} where:
     *    {Error} err - subscription error (none at the moment!)
     *    {Array} granted - array of {topic: 't', qos: 0}
     * @returns {MqttClient} this - for chaining
     * @api public
     * @example client.subscribe('topic');
     * @example client.subscribe('topic', {qos: 1});
     * @example client.subscribe({'topic': 0, 'topic2': 1}, console.log);
     * @example client.subscribe('topic', console.log);
     */
    subscribe(topics: string | string[] | Dict<number>, opts?: SubscribeOptions | Callback, callback?: Callback): this | undefined;
    /**
     * unsubscribe - unsubscribe from topic(s)
     *
     * @param {String, Array} topic - topics to unsubscribe from
     * @param {Function} [callback] - callback fired on unsuback
     * @returns {MqttClient} this - for chaining
     * @api public
     * @example client.unsubscribe('topic');
     * @example client.unsubscribe('topic', console.log);
     */
    unsubscribe(topic: string | string[], callback?: typeof nop): this;
    /**
     * end - close connection
     *
     * @returns {MqttClient} this - for chaining
     * @param {Boolean} force - do not wait for all in-flight messages to be acked
     * @param {Function} cb - called when the client has been closed
     *
     * @api public
     */
    end(force?: boolean | Callback, cb?: Callback): this;
    /**
     * removeOutgoingMessage - remove a message in outgoing store
     * the outgoing callback will be called withe Error('Message removed') if the message is removed
     *
     * @param {Number} mid - messageId to remove message
     * @returns {MqttClient} this - for chaining
     * @api public
     *
     * @example client.removeOutgoingMessage(client.getLastMessageId());
     */
    removeOutgoingMessage(mid: number): this;
    /**
     * reconnect - connect again using the same options as connect()
     *
     * @param {Object} [opts] - optional reconnect options, includes:
     *    {Store} incomingStore - a store for the incoming packets
     *    {Store} outgoingStore - a store for the outgoing packets
     *    if opts is not given, current stores are used
     * @returns {MqttClient} this - for chaining
     *
     * @api public
     */
    reconnect(opts?: CreateOptions): this;
    /**
     * _reconnect - implement reconnection
     * @api privateish
     */
    private _reconnect;
    /**
     * _setupReconnect - setup reconnect timer
     */
    private _setupReconnect;
    /**
     * _clearReconnect - clear the reconnect timer
     */
    private _clearReconnect;
    /**
     * _cleanUp - clean up on connection end
     * @api private
     */
    private _cleanUp;
    /**
     * _sendPacket - send or queue a packet
     * @param {String} type - packet type (see `protocol`)
     * @param {Object} packet - packet options
     * @param {Function} cb - callback when the packet is sent
     * @api private
     */
    private _sendPacket;
    /**
     * _setupPingTimer - setup the ping timer
     *
     * @api private
     */
    private _setupPingTimer;
    /**
     * _shiftPingInterval - reschedule the ping interval
     *
     * @api private
     */
    private _shiftPingInterval;
    /**
     * _checkPing - check if a pingresp has come back, and ping the server again
     *
     * @api private
     */
    private _checkPing;
    /**
     * _handlePingresp - handle a pingresp
     *
     * @api private
     */
    private _handlePingresp;
    /**
     * _handleConnack
     *
     * @param {Object} packet
     * @api private
     */
    private _handleConnack;
    /**
     * _handlePublish
     *
     * @param {Object} packet
     * @api private
     */
    private _handlePublish;
    /**
     * Handle messages with backpressure support, one at a time.
     * Override at will.
     *
     * @param Packet packet the packet
     * @param Function callback call when finished
     * @api public
     */
    handleMessage(packet: Packet, callback?: Callback): void;
    /**
     * _handleAck
     *
     * @param {Object} packet
     * @api private
     */
    private _handleAck;
    /**
     * _handlePubrel
     *
     * @param {Object} packet
     * @api private
     */
    private _handlePubrel;
    /**
     * _nextId
     * @return unsigned int
     */
    private __nextId;
    /**
     * getLastMessageId
     * @return unsigned int
     */
    getLastMessageId(): number;
}
export {};
