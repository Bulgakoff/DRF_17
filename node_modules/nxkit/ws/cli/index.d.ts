import { Notification, Event, EventNoticer } from '../../event';
import { DataBuilder } from '../data';
import * as conv from './conv';
export * from './conv';
export declare const METHOD_CALL_TIMEOUT = 120000;
declare class WSConversationIMPL extends conv.WSConversation {
    initialize(): void;
    send(): Promise<void>;
    ping(): Promise<void>;
    pong(): Promise<void>;
}
interface WSConversationConstructor {
    new (path: string): WSConversationIMPL;
}
export declare var WSConversation: WSConversationConstructor;
/**
 * @class WSClient
 */
export declare class WSClient extends Notification implements conv.MessageHandle {
    private m_calls;
    private m_loaded;
    private m_sends;
    private m_service_name;
    private m_conv;
    private m_Intervalid;
    get name(): string;
    get conv(): conv.WSConversation;
    get loaded(): boolean;
    readonly onLoad: EventNoticer<Event<any, object>>;
    /**
     * @constructor constructor(service_name, conv)
     */
    constructor(service_name: string, conv: conv.WSConversation);
    private _checkMethodName;
    /**
     * @func receiveMessage(msg)
     */
    receiveMessage(msg: DataBuilder): Promise<void>;
    /**
     * @class handleCall
     */
    protected handleCall(method: string, data: any, sender?: string): any;
    private _send;
    private _checkTimeout;
    private _call;
    /**
     * @func call(method, data, timeout)
     */
    call<T = any>(method: string, data?: any, timeout?: number, sender?: string): Promise<T>;
    /**
     * @func send(method, data, sender) method call
     */
    send(method: string, data?: any, sender?: string): Promise<void>;
}
