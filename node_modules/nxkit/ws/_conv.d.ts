import { Data } from './data';
import { IBuffer } from '../buffer';
import { EventNoticer, Event } from '../event';
export declare const KEEP_ALIVE_TIME = 50000;
export interface MessageHandle {
    receiveMessage(data: Data): Promise<void>;
}
export declare abstract class ConversationBasic {
    protected m_overflow: boolean;
    protected m_last_packet_time: number;
    protected m_KEEP_ALIVE_TIME: number;
    protected m_isGzip: boolean;
    protected m_replyPong: boolean;
    protected m_handles: Dict<MessageHandle>;
    protected m_services_count: number;
    protected m_token: string;
    protected m_isOpen: boolean;
    protected m_default_service: string;
    readonly onClose: EventNoticer<Event<any, object>>;
    readonly onOpen: EventNoticer<Event<any, object>>;
    readonly onPing: EventNoticer<Event<import("../buffer").InterfaceBuffer, object>>;
    readonly onPong: EventNoticer<Event<import("../buffer").InterfaceBuffer, object>>;
    readonly onDrain: EventNoticer<Event<any, object>>;
    readonly onOverflow: EventNoticer<Event<any, object>>;
    get overflow(): boolean;
    get lastPacketTime(): number;
    get keepAliveTime(): number;
    set keepAliveTime(value: number);
    get isGzip(): boolean;
    get replyPong(): boolean;
    get token(): string;
    get isOpen(): boolean;
    _service(service: string): string | undefined;
    get handles(): {
        [x: string]: MessageHandle;
    };
    protected abstract bindServices(services: string[]): Promise<void>;
    /**
     * @fun parse # parser message
     * @arg packet {String|Buffer}
     * @arg {Boolean} isText
     */
    protected handlePacket(packet: IBuffer | string, isText: boolean): Promise<void>;
    handlePing(data: IBuffer): void;
    handlePong(data: IBuffer): void;
    sendFormatData(data: Data): Promise<void>;
    abstract send(data: IBuffer): Promise<void>;
    abstract ping(): Promise<void>;
    abstract pong(): Promise<void>;
    abstract close(): void;
    protected static write<A extends any[], R>(self: ConversationBasic, api: (...args: any[]) => R, args: A): Promise<void>;
}
