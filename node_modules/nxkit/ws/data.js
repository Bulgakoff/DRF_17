"use strict";
/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2015, xuewen.chu
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of xuewen.chu nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL xuewen.chu BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("../util");
const jsonb_1 = require("../jsonb");
const event_1 = require("../event");
var Types;
(function (Types) {
    Types[Types["T_BIND"] = 241] = "T_BIND";
    Types[Types["T_EVENT"] = 242] = "T_EVENT";
    Types[Types["T_CALL"] = 243] = "T_CALL";
    Types[Types["T_CALLBACK"] = 244] = "T_CALLBACK";
    Types[Types["T_PING"] = 245] = "T_PING";
    Types[Types["T_PONG"] = 246] = "T_PONG";
})(Types = exports.Types || (exports.Types = {}));
function gen_func(queue, api) {
    return function (buffer) {
        return new Promise((resolve, reject) => {
            var item = queue.push({ resolve, reject });
            api(buffer, function (error, data) {
                item.value.result = { error, data };
                var first = queue.first;
                while (first) {
                    var { result, resolve, reject } = first.value;
                    if (result) {
                        if (result.error) {
                            reject(result.error);
                        }
                        else {
                            resolve(result.data);
                        }
                        queue.shift();
                        first = queue.first;
                    }
                    else {
                        break;
                    }
                }
            });
        });
    };
}
var _ungzip;
var _gzip;
if (util_1.default.haveNode) {
    var zlib = require('zlib');
    _ungzip = gen_func(new event_1.List(), zlib.inflateRaw);
    _gzip = gen_func(new event_1.List(), zlib.deflateRaw);
}
function ungzip(buffer) {
    return zlib ? _ungzip(buffer) : buffer;
}
exports.PING_BUFFER = jsonb_1.default.binaryify(Types.T_PING);
exports.PONG_BUFFER = jsonb_1.default.binaryify(Types.T_PONG);
function toBuffer(data, isGzip) {
    var bf = jsonb_1.default.binaryify(data);
    if (isGzip && _gzip) {
        return _gzip(bf);
    }
    else {
        return Promise.resolve(bf);
    }
}
class DataBuilder {
    constructor(opts) {
        Object.assign(this, opts);
    }
    static async parse(packet, isText, isGzip = false) {
        try {
            if (!isText && packet.length === 2) { // PING_BUFFER, PONG_BUFFER
                let type = packet[1];
                if (type == Types.T_PING || type == Types.T_PONG) {
                    return new DataBuilder({ type });
                }
            }
            var [type, service, name, data, error, cb, sender] = isText ?
                JSON.parse(packet) : jsonb_1.default.parse(isGzip ? await ungzip(packet) : packet);
            return new DataBuilder({ type, service, name, data, error, cb, sender });
        }
        catch (err) {
            console.warn('no parse EXT buffer data', err, packet.length);
        }
    }
    builder(isGzip = false) {
        return toBuffer([
            this.type, this.service, this.name,
            this.data, this.error, this.cb, this.sender
        ], isGzip);
    }
    toJSON() {
        return [
            this.type, this.service, this.name,
            this.data, this.error, this.cb, this.sender
        ];
    }
    isPing() {
        return this.type == Types.T_PING;
    }
    isPong() {
        return this.type == Types.T_PONG;
    }
    isBind() {
        return this.type == Types.T_BIND;
    }
    isEvent() {
        return this.type == Types.T_EVENT;
    }
    isCall() {
        return this.type == Types.T_CALL;
    }
    isCallback() {
        return this.type == Types.T_CALLBACK;
    }
}
exports.DataBuilder = DataBuilder;
