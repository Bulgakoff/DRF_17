import * as doc from './document';
import * as el from './element';
import * as nnm from './named_node_map';
export declare enum NODE_TYPE {
    NODE_NODE = 1,
    ELEMENT_NODE = 1,
    ATTRIBUTE_NODE = 2,
    TEXT_NODE = 3,
    CDATA_SECTION_NODE = 4,
    ENTITY_REFERENCE_NODE = 5,
    ENTITY_NODE = 6,
    PROCESSING_INSTRUCTION_NODE = 7,
    COMMENT_NODE = 8,
    DOCUMENT_NODE = 9,
    DOCUMENT_TYPE_NODE = 10,
    DOCUMENT_FRAGMENT_NODE = 11,
    NOTATION_NODE = 12
}
export declare class Node {
    readonly ownerDocument: doc.Document;
    readonly nodeType?: NODE_TYPE;
    readonly childNodes?: NodeList;
    readonly attributes?: nnm.NamedNodeMap;
    readonly nodeName?: string;
    firstChild?: Node;
    lastChild?: Node;
    previousSibling?: Node;
    nextSibling?: Node;
    parentNode?: Node;
    nodeValue?: string;
    namespaceURI?: string;
    localName?: string;
    prefix?: string;
    constructor(ownerDocument: doc.Document);
    insertBefore(newChild: Node, refChild: Node | null): void;
    replaceChild(newChild: Node, oldChild: Node): void;
    removeAllChild(): void;
    removeChild(oldChild: Node): Node | null;
    appendChild(newChild: Node): void;
    hasChildNodes(): boolean;
    cloneNode(deep?: boolean): null;
    normalize(): void;
    isSupported(feature: string, version: string): boolean;
    hasAttributes(): boolean;
    lookupPrefix(namespaceURI: string): string | null;
    isDefaultNamespace(namespaceURI: string): boolean;
    lookupNamespaceURI(prefix: string): string | null;
    toString(): string;
}
/**
    * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177
    * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.
    * The items in the NodeList are accessible via an integral index, starting from 0.
    */
export declare class NodeList {
    /**
        * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
        * @standard level1
        */
    protected _length: number;
    get length(): number;
    /**
        * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
        * @standard level1
        * @param index  unsigned long
        *   Index into the collection.
        * @return Node
        * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
        */
    item(index: number): Node | null;
}
export declare class LiveNodeList extends NodeList {
    private _node;
    private _refresh;
    private _inc;
    private _updateLiveNodeList;
    get length(): number;
    constructor(node: Node, refresh: (n: Node) => Node[]);
    item(index: number): Node | null;
}
declare class CharacterData extends Node {
    data: string;
    length: number;
    get nodeValue(): string;
    substringData(offset: number, count: number): string;
    appendData(text: string): void;
    insertData(offset: number, text: string): void;
    deleteData(offset: number, count: number): void;
    replaceData(offset: number, count: number, text: string): void;
}
export declare class Attribute extends CharacterData {
    readonly nodeType = NODE_TYPE.ATTRIBUTE_NODE;
    ownerElement: el.Element | null;
    readonly name: string;
    readonly specified: boolean;
    value: string;
    get nodeValue(): string;
    get nodeName(): string;
    constructor(doc: doc.Document, name: string, value: string, specified?: boolean);
}
export declare class CDATASection extends CharacterData {
    readonly nodeType = NODE_TYPE.CDATA_SECTION_NODE;
    readonly nodeName = "#cdata-section";
}
export declare class Comment extends CharacterData {
    readonly nodeType = NODE_TYPE.COMMENT_NODE;
    readonly nodeName = "#comment";
}
export declare class DocumentFragment extends Node {
    readonly nodeName = "#document-fragment";
    readonly childNodes: NodeList;
}
export declare class DocumentType extends Node {
    readonly nodeName: string;
    readonly nodeType = NODE_TYPE.DOCUMENT_TYPE_NODE;
    readonly name: string;
    readonly publicId: string;
    readonly systemId: string;
    readonly internalSubset?: string;
    /**
        * constructor function
        * @constructor
        * @param {String}              qualifiedName
        * @param {String}              publicId
        * @param {String}              systemId
        */
    constructor(doc: doc.Document, qualifiedName: string, publicId: string, systemId: string, internalSubset?: string);
}
export declare class Entity extends Node {
    readonly nodeType = NODE_TYPE.ENTITY_NODE;
    readonly nodeName = "#entity";
}
export declare class EntityReference extends Node {
    readonly nodeType = NODE_TYPE.ENTITY_REFERENCE_NODE;
    readonly nodeName: string;
    get text(): string | undefined;
    constructor(doc: doc.Document, nodeName: string, nodeValue?: string);
}
export declare class Notation extends Node {
    readonly nodeType = NODE_TYPE.NOTATION_NODE;
    readonly nodeName = "#notation";
}
export declare class ProcessingInstruction extends Node {
    readonly nodeType = NODE_TYPE.PROCESSING_INSTRUCTION_NODE;
    readonly name: string;
    readonly data: string;
    get nodeName(): string;
    constructor(doc: doc.Document, name: string, data: string);
}
export declare class Text extends CharacterData {
    readonly nodeName = "#text";
    readonly nodeType = NODE_TYPE.TEXT_NODE;
    splitText(offset: number): Text;
}
export {};
