"use strict";
/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2015, xuewen.chu
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of xuewen.chu nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL xuewen.chu BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */
Object.defineProperty(exports, "__esModule", { value: true });
const node_1 = require("./node");
const element_1 = require("./element");
const parser = require("./parser");
var Node_insertBefore = node_1.Node.prototype.insertBefore;
var Node_removeChild = node_1.Node.prototype.removeChild;
class Document extends node_1.Node {
    // Introduced in DOM Level 2:
    /**
        * constructor function
        * @constructor
        * @param {String}              namespaceURI
        * @param {String}              qualifiedName
        * @param {tesla.xml.DocumentType} doctype
        */
    constructor(namespaceURI, qualifiedName, doctype) {
        super(null);
        this.nodeName = '#document';
        this.nodeType = node_1.NODE_TYPE.DOCUMENT_NODE;
        this.childNodes = new node_1.NodeList();
        this._documentElement = null;
        this._inc = 1;
        this.ownerDocument = this;
        // raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR,WRONG_DOCUMENT_ERR
        this.doctype = doctype || null;
        if (this.doctype) {
            this.appendChild(this.doctype);
        }
        if (qualifiedName) {
            var root = this.createElementNS(namespaceURI || '', qualifiedName);
            this.appendChild(root);
        }
    }
    get documentElement() {
        return this._documentElement;
    }
    load(text) {
        return new parser.Parser().fragment(this, text);
    }
    insertBefore(newChild, refChild) {
        if (newChild.nodeType == node_1.NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {
            var child = newChild.firstChild;
            while (child) {
                this.insertBefore(newChild, refChild);
                child = child.nextSibling;
            }
            return newChild;
        }
        if (this._documentElement === null && newChild.nodeType == node_1.NODE_TYPE.ELEMENT_NODE)
            this._documentElement = newChild;
        Node_insertBefore.call(this, newChild, refChild);
        return newChild;
    }
    removeChild(oldChild) {
        if (this.documentElement == oldChild) {
            this._documentElement = null;
        }
        return Node_removeChild.call(this, oldChild);
    }
    // Introduced in DOM Level 2:
    importNode(importedNode, deep) {
        // TODO Unrealized
        return null;
    }
    // Introduced in DOM Level 2:
    getElementById(id) {
        var rtv = null;
        element_1.visitNode(this.documentElement, function (node) {
            if (node.nodeType == node_1.NODE_TYPE.ELEMENT_NODE) {
                if (node.getAttribute('id') == id) {
                    rtv = node;
                    return false;
                }
                return true;
            }
            return false;
        });
        return rtv;
    }
    getElementsByTagName(name) {
        var el = this.documentElement;
        return el ?
            el.getElementsByTagName(name) : new node_1.NodeList();
    }
    getElementsByTagNameNS(namespaceURI, localName) {
        var el = this.documentElement;
        return el ?
            el.getElementsByTagNameNS(namespaceURI, localName) : new node_1.NodeList();
    }
    //document factory method:
    createElement(tagName) {
        return new element_1.Element(this, tagName);
    }
    createDocumentFragment() {
        return new node_1.DocumentFragment(this);
    }
    createTextNode(data) {
        var r = new node_1.Text(this);
        r.appendData(data);
        return r;
    }
    createComment(data) {
        var r = new node_1.Comment(this);
        r.appendData(data);
        return r;
    }
    createCDATASection(data) {
        var r = new node_1.CDATASection(this);
        r.appendData(data);
        return r;
    }
    createProcessingInstruction(target, data) {
        return new node_1.ProcessingInstruction(this, target, data);
    }
    createAttribute(name, value) {
        return new node_1.Attribute(this, name, value, true);
    }
    createEntityReference(name, value) {
        return new node_1.EntityReference(this, name, value);
    }
    // Introduced in DOM Level 2:
    createElementNS(namespaceURI, qualifiedName) {
        var el = new element_1.Element(this, qualifiedName);
        var pl = qualifiedName.split(':');
        el.namespaceURI = namespaceURI;
        if (pl.length == 2) {
            el.prefix = pl[0];
            el.localName = pl[1];
        }
        else {
            el.localName = qualifiedName;
        }
        return el;
    }
    // Introduced in DOM Level 2:
    createAttributeNS(namespaceURI, qualifiedName, value) {
        var r = new node_1.Attribute(this, qualifiedName, value, true);
        var pl = qualifiedName.split(':');
        r.namespaceURI = namespaceURI;
        if (pl.length == 2) {
            r.prefix = pl[0];
            r.localName = pl[1];
        }
        else {
            r.localName = qualifiedName;
        }
        return r;
    }
    toJSON() {
        var first = this.firstChild;
        if (!first)
            return null;
        var result = {};
        var ns = first.childNodes;
        if (!ns)
            return null;
        for (var i = 0; i < ns.length; i++) {
            var node = ns.item(i);
            if (node.nodeType === node_1.NODE_TYPE.ELEMENT_NODE) {
                var el = node;
                if (node.lastChild) {
                    if (node.lastChild.nodeType == node_1.NODE_TYPE.CDATA_SECTION_NODE) { // cdata
                        result[el.tagName] = node.lastChild.data;
                    }
                    else {
                        result[el.tagName] = el.innerXml;
                    }
                }
                else {
                    result[el.tagName] = '';
                }
            }
        }
        return result;
    }
}
exports.Document = Document;
