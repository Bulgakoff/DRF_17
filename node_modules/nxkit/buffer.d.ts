export declare const TypedArrayConstructor: any;
export declare type TypedArray = Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array | Int8Array | Int16Array | Int32Array | Float32Array | Float64Array;
export declare type ArrayIBufferView = TypedArray | DataView;
export declare type Bytes = Uint8Array | Uint8ClampedArray;
export declare type BinaryLike = ArrayBufferView | ArrayBuffer | SharedArrayBuffer;
export declare type FromArg = string | BinaryLike | Iterable<number> | ArrayLike<number>;
export declare type IBuffer = InterfaceBuffer;
export declare function isInterfaceBuffer(IBuffer: any): boolean;
export declare function isTypedArray(arr: TypedArray): boolean;
export declare type IBufferEncoding = "ascii" | "utf8" | "utf-8" | "base64" | "latin1" | "binary" | "hex";
export interface InterfaceBuffer extends Uint8Array {
    toString(encoding?: string, start?: number, end?: number): string;
    copy(targetIBuffer: IBuffer, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;
    clone(start?: number, end?: number): IBuffer;
    slice(start?: number, end?: number): IBuffer;
    filter(callbackfn: (value: number, index: number, array: IBuffer) => any, thisArg?: any): IBuffer;
    map(callbackfn: (value: number, index: number, array: IBuffer) => number, thisArg?: any): IBuffer;
    reverse(): IBuffer;
    every(callbackfn: (value: number, index: number, array: IBuffer) => unknown, thisArg?: any): boolean;
    some(callbackfn: (value: number, index: number, array: IBuffer) => unknown, thisArg?: any): boolean;
    subarray(begin?: number, end?: number): IBuffer;
    toJSON(): {
        type: 'InterfaceBuffer';
        data: number[];
    };
    write(arg0: FromArg, offset?: number, encoding?: IBufferEncoding): number;
    readInt8(offset?: number): number;
    readUInt8(offset?: number): number;
    readInt16BE(offset?: number): number;
    readUInt16BE(offset?: number): number;
    readInt32BE(offset?: number): number;
    readUInt32BE(offset?: number): number;
    readInt40BE(offset?: number): number;
    readUInt40BE(offset?: number): number;
    readInt48BE(offset?: number): number;
    readUInt48BE(offset?: number): number;
    readBigInt64BE(offset?: number): bigint;
    readBigUInt64BE(offset?: number): bigint;
    readIntBE(offset?: number, byteLength?: number): number;
    readUIntBE(offset?: number, byteLength?: number): number;
    readFloatBE(offset?: number): number;
    readDoubleBE(offset?: number): number;
    readBigUIntBE(offset?: number, end?: number): bigint;
    writeInt8(value: number, offset?: number): number;
    writeUInt8(value: number, offset?: number): number;
    writeInt16BE(value: number, offset?: number): number;
    writeUInt16BE(value: number, offset?: number): number;
    writeInt32BE(value: number, offset?: number): number;
    writeUInt32BE(value: number, offset?: number): number;
    writeInt48BE(value: number, offset?: number): number;
    writeUInt48BE(value: number, offset?: number): number;
    writeBigInt64BE(value: bigint, offset?: number): number;
    writeBigUInt64BE(value: bigint, offset?: number): number;
    writeIntBE(value: number, offset?: number, byteLength?: number): number;
    writeUIntBE(value: number, offset?: number, byteLength?: number): number;
    writeFloatBE(value: number, offset?: number): number;
    writeDoubleBE(value: number, offset?: number): number;
    writeBigIntLE(bigint: bigint, offset?: number): number;
}
declare function byteLength(string: string | BinaryLike, encoding?: IBufferEncoding): number;
declare function from(value: FromArg, encodingOrMapfn?: IBufferEncoding | ((v: number, k: number) => number), thisArg?: any): IBuffer;
declare function alloc(size: number): IBuffer;
declare function allocUnsafe(size: number): IBuffer;
declare function concat(list: (Bytes | ArrayLike<number>)[], length?: number): IBuffer;
export declare const Zero: InterfaceBuffer;
declare const _default: {
    byteLength: typeof byteLength;
    isInterfaceBuffer: typeof isInterfaceBuffer;
    from: typeof from;
    alloc: typeof alloc;
    allocUnsafe: typeof allocUnsafe;
    concat: typeof concat;
};
export default _default;
