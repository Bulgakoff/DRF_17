/// <reference types="node" />
import { EventNoticer, Event } from './event';
import * as crypto from 'crypto';
import { StaticService } from './static_service';
import * as http from 'http';
export declare enum STATUS {
    PARSER_UNINITIALIZED = 0,
    START = 1,
    START_BOUNDARY = 2,
    HEADER_FIELD_START = 3,
    HEADER_FIELD = 4,
    HEADER_VALUE_START = 5,
    HEADER_VALUE = 6,
    HEADER_VALUE_ALMOST_DONE = 7,
    HEADERS_ALMOST_DONE = 8,
    PART_DATA_START = 9,
    PART_DATA = 10,
    PART_END = 11,
    END = 12
}
export declare class File {
    private _writeStream;
    private _path;
    private _name;
    private _type;
    private _size;
    private _lastModifiedDate;
    get size(): number;
    get length(): number;
    get filename(): string;
    get pathname(): string;
    get mime(): string;
    get lastModifiedDate(): number;
    readonly onProgress: EventNoticer<number>;
    readonly onEnd: EventNoticer<Event<any, object>>;
    constructor(path: string, name: string, type: string);
    private _open;
    write(buffer: Buffer, cb: any): void;
    end(cb: any): void;
}
declare class Part {
    headers: Dict<string>;
    name: string;
    filename: string;
    mime: string;
    headerField: string;
    headerValue: string;
    readonly onData: EventNoticer<Event<Buffer, object>>;
    readonly onEnd: EventNoticer<Event<any, object>>;
}
export interface ProgressData {
    bytesReceived: number;
    bytesExpected: number;
}
export interface FieldData {
    name: string;
    value: string;
}
export interface FileData {
    name: string;
    file: File;
}
export declare class IncomingForm {
    private _parser;
    private _flushing;
    private _fields_size;
    private _service;
    private _error;
    private _ended;
    readonly hash: crypto.Hash;
    get ended(): boolean;
    /**
     * default size 2MB
     * @type {Number}
     */
    readonly maxFieldsSize: number;
    /**
     * default size 5MB
     * @type {Number}
     */
    readonly maxFilesSize: number;
    /**
     * verifyFileMime 'js|jpg|jpeg|png' default as '*' ...
     * @type {String}
     */
    readonly verifyFileMime = "*";
    /**
     * is use file upload, default not upload
     * @type {Boolean}
     */
    isUpload: boolean;
    readonly fields: Dict;
    readonly files: Dict<File[]>;
    keepExtensions: boolean;
    uploadDir: string;
    encoding: string;
    headers: http.IncomingHttpHeaders;
    type: string;
    private bytesReceived;
    private bytesExpected;
    readonly onAborted: EventNoticer<Event<any, object>>;
    readonly onProgress: EventNoticer<ProgressData>;
    readonly onField: EventNoticer<FieldData>;
    readonly onFileBegin: EventNoticer<FileData>;
    readonly onFile: EventNoticer<FileData>;
    readonly onError: EventNoticer<Error>;
    readonly onEnd: EventNoticer<Event<any, object>>;
    /**
     * constructor function
     * @param {HttpService}
     * @constructor
     */
    constructor(service: StaticService);
    _canceled(): void;
    /**
     * parse
     */
    parse(): void;
    write(buffer: Buffer): number | undefined;
    pause(): boolean;
    resume(): boolean;
    onpart(part: Part): void;
    handle_part(part: Part): void;
    _parseContentType(): void;
    _throwError(err: Error): void;
    _parseContentLength(): void;
    _fileName(headerValue: string): string | undefined;
    _initMultipart(boundary: string): void;
    private _initUrlencodedOrJsonOrXml;
    private _uploadPath;
    private _maybeEnd;
}
declare function stateToString(stateNumber: number): string;
declare const _default: {
    IncomingForm: typeof IncomingForm;
    temp_dir: string;
    STATUS: typeof STATUS;
    stateToString: typeof stateToString;
};
export default _default;
