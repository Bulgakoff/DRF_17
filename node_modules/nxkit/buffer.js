"use strict";
/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2015, xuewen.chu
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, self list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, self list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of xuewen.chu nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from self software without specific prior written permission.
 *
 * self SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL xuewen.chu BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF self
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("./util");
const _codec_1 = require("./_codec");
const _buffer_1 = require("./_buffer");
const MathFloor = Math.floor;
const INTERFACE_IBuffer_TYPE = -12378;
exports.TypedArrayConstructor = Uint8Array.prototype.__proto__.constructor;
function isInterfaceBuffer(IBuffer) {
    if (IBuffer && IBuffer.__INTERFACE_IBuffer_TYPE__ == INTERFACE_IBuffer_TYPE)
        return true;
    return false;
}
exports.isInterfaceBuffer = isInterfaceBuffer;
function isTypedArray(arr) {
    return arr instanceof exports.TypedArrayConstructor;
}
exports.isTypedArray = isTypedArray;
function toInteger(n, defaultVal) {
    n = +n;
    if (!Number.isNaN(n) &&
        n >= Number.MIN_SAFE_INTEGER &&
        n <= Number.MAX_SAFE_INTEGER) {
        return ((n % 1) === 0 ? n : MathFloor(n));
    }
    return defaultVal;
}
function copy(source, target, targetStart, sourceStart, sourceEnd) {
    if (!isTypedArray(source))
        throw _buffer_1.ERR_INVALID_ARG_TYPE(source, ['IBuffer', 'TypedArray'], 'source');
    if (!isTypedArray(target))
        throw _buffer_1.ERR_INVALID_ARG_TYPE(target, ['IBuffer', 'TypedArray'], 'target');
    if (targetStart === undefined) {
        targetStart = 0;
    }
    else {
        targetStart = toInteger(targetStart, 0);
        if (targetStart < 0)
            throw _buffer_1.ERR_OUT_OF_RANGE('targetStart', '>= 0', targetStart);
    }
    if (sourceStart === undefined) {
        sourceStart = 0;
    }
    else {
        sourceStart = toInteger(sourceStart, 0);
        if (sourceStart < 0)
            throw _buffer_1.ERR_OUT_OF_RANGE('sourceStart', '>= 0', sourceStart);
    }
    if (sourceEnd === undefined) {
        sourceEnd = source.byteLength;
    }
    else {
        sourceEnd = toInteger(sourceEnd, 0);
        if (sourceEnd < 0)
            throw _buffer_1.ERR_OUT_OF_RANGE('sourceEnd', '>= 0', sourceEnd);
    }
    if (targetStart >= target.byteLength || sourceStart >= sourceEnd)
        return 0;
    if (sourceStart > source.byteLength) {
        throw _buffer_1.ERR_OUT_OF_RANGE('sourceStart', `<= ${source.byteLength}`, sourceStart);
    }
    if (sourceEnd - sourceStart > target.byteLength - targetStart)
        sourceEnd = sourceStart + target.byteLength - targetStart;
    let nb = sourceEnd - sourceStart;
    const targetLen = target.byteLength - targetStart;
    const sourceLen = source.byteLength - sourceStart;
    if (nb > targetLen)
        nb = targetLen;
    if (nb > sourceLen)
        nb = sourceLen;
    var src;
    if (sourceStart !== 0 || sourceEnd !== source.byteLength)
        src = new Uint8Array(source.buffer, source.byteOffset + sourceStart, nb);
    else
        src = new Uint8Array(source.buffer);
    (new Uint8Array(target.buffer)).set(src, targetStart);
    return nb;
}
function byteLength(string, encoding) {
    if (typeof string !== 'string') {
        if ('byteLength' in string
        /*string as BinaryLike */
        /*string instanceof ArrayIBuffer || string instanceof TypedArray*/ ) {
            return string.byteLength;
        }
        throw _buffer_1.ERR_INVALID_ARG_TYPE(string, ['string', 'IBuffer', 'ArrayIBuffer', 'SharedArrayIBuffer', 'DataView'], 'string');
    }
    if (encoding == 'utf8' || encoding == 'utf-8') {
        return _codec_1.default.encodeUTF8Length(string);
    }
    else if (encoding == 'hex') {
        util_1.default.assert(string.length % 2 === 0, `encoding error, ${encoding}`);
        return string.length / 2;
    }
    else if (encoding == 'base64') {
        util_1.default.assert(string.length % 4 === 0, `encoding error, ${encoding}`);
        if (string.substr(string.length - 1) == '=') {
            if (string.substr(string.length - 2) == '=')
                return string.length / 4 * 3 - 2;
            else
                return string.length / 4 * 3 - 1;
        }
        else {
            return string.length / 4 * 3;
        }
    }
    else if (encoding == 'latin1' || encoding == 'binary') {
        return string.length;
    }
    else if (encoding == 'ascii') {
        return string.length;
    }
    else {
        return _codec_1.default.encodeUTF8Length(string);
    }
}
function from(value, encodingOrMapfn, thisArg) {
    if (typeof value === 'string') {
        var encoding = typeof encodingOrMapfn == 'string' ? encodingOrMapfn : 'utf8';
        if (encoding == 'utf8' || encoding == 'utf-8') {
            return new IBufferIMPL(_codec_1.default.encodeUTF8(value));
        }
        else if (encoding == 'hex') {
            return new IBufferIMPL(_codec_1.default.decodeHex(value));
        }
        else if (encoding == 'base64') {
            return new IBufferIMPL(_codec_1.default.decodeBase64(value));
        }
        else if (encoding == 'latin1' || encoding == 'binary') {
            return new IBufferIMPL(_codec_1.default.encodeLatin1From(value));
        }
        else if (encoding == 'ascii') {
            return new IBufferIMPL(_codec_1.default.encodeAsciiFrom(value));
        }
        else {
            return new IBufferIMPL(_codec_1.default.encodeUTF8(value));
        }
    }
    else if (value instanceof exports.TypedArrayConstructor) {
        var bf = value;
        return new IBufferIMPL(bf.buffer, bf.byteOffset, bf.byteLength);
    }
    else if (value instanceof ArrayBuffer || value instanceof SharedArrayBuffer) {
        return new IBufferIMPL(value);
    }
    else if (value instanceof DataView) {
        return new IBufferIMPL(value.buffer, value.byteOffset, value.byteLength);
    }
    else {
        var bf = Uint8Array.from(value, encodingOrMapfn, thisArg);
        bf.__proto__ = IBufferIMPL.prototype;
        return bf;
    }
}
function alloc(size) {
    return new IBufferIMPL(Number(size) || 0);
}
function allocUnsafe(size) {
    return new IBufferIMPL(Number(size) || 0);
}
function concat(list, length) {
    if (length === undefined) {
        length = 0;
        for (var bytes of list) {
            if (bytes.length) {
                length += bytes.length;
            }
        }
    }
    else {
        length = Number(length) || 0;
    }
    if (list.length === 0 || length === 0)
        return exports.Zero;
    var bf = new IBufferIMPL(length);
    var offset = 0;
    for (var bytes of list) {
        if (bytes.length) {
            bf.set(bytes, offset);
            offset += bytes.length;
        }
    }
    return bf;
}
class IBufferIMPL extends Uint8Array {
    toString(encoding = 'utf8', start = 0, end = this.length) {
        if (encoding) {
            if (encoding == 'utf8' || encoding == 'utf-8') {
                return _codec_1.default.decodeUTF8From(this, start, end);
            }
            else if (encoding == 'hex') {
                return _codec_1.default.encodeHexFrom(this, start, end);
            }
            else if (encoding == 'base64') {
                return _codec_1.default.encodeBase64From(this, start, end);
            }
            else if (encoding == 'latin1' || encoding == 'binary') {
                return _codec_1.default.decodeLatin1From(this, start, end);
            }
            else if (encoding == 'ascii') {
                return _codec_1.default.decodeAsciiFrom(this, start, end);
            }
            else {
                return _codec_1.default.decodeUTF8From(this, start, end);
            }
        }
        else {
            return _codec_1.default.decodeUTF8From(this, start, end);
        }
    }
    copy(targetIBuffer, targetStart, sourceStart, sourceEnd) {
        return copy(this, targetIBuffer, targetStart, sourceStart, sourceEnd);
    }
    clone(start, end) {
        return this.slice(start, end);
    }
    slice(start, end) {
        return new IBufferIMPL(super.slice(start, end).buffer);
    }
    filter(callbackfn, thisArg) {
        return new IBufferIMPL(super.filter(callbackfn, thisArg).buffer);
    }
    map(callbackfn, thisArg) {
        return new IBufferIMPL(super.map(callbackfn, thisArg).buffer);
    }
    reverse() {
        return new IBufferIMPL(super.reverse().buffer);
    }
    every(callbackfn, thisArg) {
        return super.every(callbackfn, thisArg);
    }
    some(callbackfn, thisArg) {
        return super.some(callbackfn, thisArg);
    }
    subarray(begin, end) {
        return new IBufferIMPL(super.subarray(begin, end).buffer);
    }
    toJSON() {
        var data = new Array(this.length);
        this.forEach((i, j) => data[j] = i);
        return { type: 'InterfaceBuffer', data };
    }
    write(arg0, offset, encoding) {
        var IBuffer = from(arg0, encoding);
        this.set(IBuffer, offset);
        return IBuffer.length;
    }
    readInt8(offset = 0) {
        return _buffer_1.default.readInt8(this, offset);
    }
    readUInt8(offset = 0) {
        return _buffer_1.default.readUInt8(this, offset);
    }
    readInt16BE(offset = 0) {
        return _buffer_1.default.readInt16BE(this, offset);
    }
    readUInt16BE(offset = 0) {
        return _buffer_1.default.readUInt16BE(this, offset);
    }
    readInt32BE(offset = 0) {
        return _buffer_1.default.readInt32BE(this, offset);
    }
    readUInt32BE(offset = 0) {
        return _buffer_1.default.readUInt32BE(this, offset);
    }
    readInt40BE(offset = 0) {
        return _buffer_1.default.readInt40BE(this, offset);
    }
    readUInt40BE(offset = 0) {
        return _buffer_1.default.readUInt40BE(this, offset);
    }
    readInt48BE(offset = 0) {
        return _buffer_1.default.readInt48BE(this, offset);
    }
    readUInt48BE(offset = 0) {
        return _buffer_1.default.readUInt48BE(this, offset);
    }
    readBigInt64BE(offset = 0) {
        return _buffer_1.default.readBigInt64BE(this, offset);
    }
    readBigUInt64BE(offset = 0) {
        return _buffer_1.default.readBigUInt64BE(this, offset);
    }
    readIntBE(offset = 0, byteLength = 4) {
        return _buffer_1.default.readIntBE(this, offset, byteLength);
    }
    readUIntBE(offset = 0, byteLength = 4) {
        return _buffer_1.default.readUIntBE(this, offset, byteLength);
    }
    readFloatBE(offset = 0) {
        return _buffer_1.default.readFloatBE(this, offset);
    }
    readDoubleBE(offset = 0) {
        return _buffer_1.default.readDoubleBE(this, offset);
    }
    readBigUIntBE(offset, end) {
        return _buffer_1.default.readBigUIntBE(this, offset, end);
    }
    // write
    writeInt8(value, offset = 0) {
        return _buffer_1.default.writeInt8(this, value, offset);
    }
    writeUInt8(value, offset = 0) {
        return _buffer_1.default.writeUInt8(this, value, offset);
    }
    writeInt16BE(value, offset = 0) {
        return _buffer_1.default.writeInt16BE(this, value, offset);
    }
    writeUInt16BE(value, offset = 0) {
        return _buffer_1.default.writeUInt16BE(this, value, offset);
    }
    writeInt32BE(value, offset = 0) {
        return _buffer_1.default.writeInt32BE(this, value, offset);
    }
    writeUInt32BE(value, offset = 0) {
        return _buffer_1.default.writeUInt32BE(this, value, offset);
    }
    writeInt48BE(value, offset = 0) {
        return _buffer_1.default.writeInt48BE(this, value, offset);
    }
    writeUInt48BE(value, offset = 0) {
        return _buffer_1.default.writeUInt48BE(this, value, offset);
    }
    writeBigInt64BE(value, offset = 0) {
        return _buffer_1.default.writeBigInt64BE(this, value, offset);
    }
    writeBigUInt64BE(value, offset = 0) {
        return _buffer_1.default.writeBigUInt64BE(this, value, offset);
    }
    writeIntBE(value, offset = 0, byteLength = 4) {
        return _buffer_1.default.writeIntBE(this, value, offset, byteLength);
    }
    writeUIntBE(value, offset = 0, byteLength = 4) {
        return _buffer_1.default.writeUIntBE(this, value, offset, byteLength);
    }
    writeFloatBE(value, offset = 0) {
        return _buffer_1.default.writeFloatBE(this, value, offset);
    }
    writeDoubleBE(value, offset = 0) {
        return _buffer_1.default.writeDoubleBE(this, value, offset);
    }
    writeBigIntLE(bigint, offset = 0) {
        var arr = [];
        var l = _buffer_1.default.writeBigIntLE(arr, bigint);
        this.set(arr, offset);
        return l;
    }
}
exports.Zero = alloc(0);
Object.defineProperty(IBufferIMPL.prototype, '__INTERFACE_IBuffer_TYPE__', {
    configurable: false,
    enumerable: false,
    value: INTERFACE_IBuffer_TYPE,
    writable: false,
});
exports.default = {
    byteLength,
    isInterfaceBuffer,
    from,
    alloc,
    allocUnsafe,
    concat,
};
