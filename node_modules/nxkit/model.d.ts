import * as sql from './sql_map';
export interface Options {
    dataSource?: sql.DataSource;
    table?: string;
}
export interface FetchOptions extends sql.Options {
    key?: string;
    table?: string;
    method?: string;
}
/**
 * @class ModelBasic
 */
export declare abstract class ModelBasic {
    protected m_value: any;
    protected m_ds: sql.DataSource | null;
    protected m_table: string;
    protected m_parent: ModelBasic | null;
    get baseValue(): any;
    get table(): string;
    get parent(): ModelBasic | null;
    constructor(value?: any, opts?: Options);
    toJSON(): any;
    abstract fetch(name: string, param?: sql.QueryParams, options?: FetchOptions): Promise<this>;
    abstract fetchChild(name: string, param?: sql.QueryParams, options?: FetchOptions): Promise<this>;
}
/**
 * @class Model
 */
export declare class Model<T = Dict> extends ModelBasic {
    get value(): T;
    fetch(name: string, param?: sql.QueryParams, { key, table, method, ...opts }?: FetchOptions): Promise<this>;
    fetchChild(name: string, param?: sql.QueryParams, { key, table, method, ...opts }?: FetchOptions): Promise<this>;
}
export declare type ID = string | number;
/**
 * @class Collection
 */
export declare class Collection<T = Dict> extends ModelBasic {
    private m_map;
    private m_ids;
    private m_index;
    private m_total;
    constructor(value?: Model<T>[], opts?: Options);
    get value(): Model<T>[];
    get(id: ID): Model<T> | undefined;
    get total(): number;
    set total(value: number);
    get index(): number;
    set index(value: number);
    get length(): number;
    get IDs(): (string | number)[];
    fetch(name: string, param?: sql.QueryParams, { key, table, method, ...opts }?: FetchOptions): Promise<this>;
    fetchChild(name: string, param?: sql.QueryParams, { key, table, method, ...opts }?: FetchOptions): Promise<this>;
    toJSON(): any;
}
