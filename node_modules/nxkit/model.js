"use strict";
/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2015, xuewen.chu
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of xuewen.chu nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL xuewen.chu BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("./util");
function pkeyValue(self, keyPath) {
    var m = self;
    for (var key of keyPath) {
        // TODO private visit
        m = m.m_value[key];
        if (!m)
            return m;
    }
    return m;
}
function primaryKey(mkey) {
    var [key, key2] = mkey.split('=');
    var fetchKeyPath = (key2 || key).split('.');
    return {
        pkeyName: key2 ? key : fetchKeyPath.indexReverse(0),
        fetchKeyPath,
    };
}
/**
 * @class ModelBasic
 */
class ModelBasic {
    constructor(value = null, opts = {}) {
        this.m_parent = null;
        this.m_value = value;
        this.m_ds = opts.dataSource || null;
        this.m_table = opts.table || '';
    }
    get baseValue() {
        return this.m_value;
    }
    get table() {
        return this.m_table;
    }
    get parent() {
        return this.m_parent;
    }
    toJSON() {
        return this.m_value;
    }
}
exports.ModelBasic = ModelBasic;
/**
 * @class Model
 */
class Model extends ModelBasic {
    get value() {
        return this.m_value;
    }
    async fetch(name, param, { key, table, method = 'select', ...opts } = {}) {
        var _table = table || name;
        var ds = this.m_ds;
        util_1.default.assert(ds);
        var { pkeyName, fetchKeyPath } = primaryKey(key || ds.primaryKey(_table));
        var model = await ds.dao[_table][method].get({ [pkeyName]: pkeyValue(this, fetchKeyPath), ...param }, opts);
        this.m_value[name] = model;
        return this;
    }
    async fetchChild(name, param, { key, table, method = 'select', ...opts } = {}) {
        var _table = table || name;
        var ds = this.m_ds;
        util_1.default.assert(ds);
        var { pkeyName, fetchKeyPath } = primaryKey(key || ds.primaryKey(this.m_table));
        var collection = await ds.dao[_table][method]({ [pkeyName]: pkeyValue(this, fetchKeyPath), limit: 0, ...param }, opts);
        // TODO private visit
        collection.m_parent = this;
        this.m_value[name] = collection;
        return this;
    }
}
exports.Model = Model;
/**
 * @class Collection
 */
class Collection extends ModelBasic {
    constructor(value = [], opts = {}) {
        super(value, opts);
        this.m_map = new Map();
        this.m_ids = [];
        this.m_index = 0;
        this.m_total = 0;
        var ds = this.m_ds;
        util_1.default.assert(ds);
        var pk = ds.primaryKey(this.m_table);
        for (var m of this.m_value) {
            var id = m.value[pk];
            if (id) {
                this.m_ids.push(id);
                this.m_map.set(id, m);
            }
        }
    }
    get value() {
        return this.m_value;
    }
    get(id) {
        return this.m_map.get(id);
    }
    get total() {
        return this.m_total || this.length;
    }
    set total(value) {
        this.m_total = Number(value) || 0;
    }
    get index() {
        return this.m_index;
    }
    set index(value) {
        this.m_index = Number(value) || 0;
    }
    get length() {
        return this.m_value.length;
    }
    get IDs() {
        return this.m_ids;
    }
    async fetch(name, param, { key, table, method = 'select', ...opts } = {}) {
        var _table = table || name;
        var ds = this.m_ds;
        util_1.default.assert(ds);
        var pk0 = ds.primaryKey(_table);
        var { pkeyName, fetchKeyPath } = primaryKey(key || pk0);
        var ids_set = new Set;
        var ids = this.value
            .map((m) => pkeyValue(m, fetchKeyPath))
            .filter((e) => {
            if (e) {
                if (!ids_set.has(e)) {
                    ids_set.add(e);
                    return true;
                }
            }
            return false;
        });
        if (ids.length) {
            var collection = await ds.dao[_table][method]({ [pkeyName]: ids, limit: 0, ...param }, opts);
            var map = collection.m_map;
            if (pkeyName != pk0) {
                map = new Map();
                for (var m of collection.value) {
                    var id = m.value[pkeyName];
                    if (id)
                        map.set(id, m);
                }
            }
            this.value.forEach(e => {
                // TODO private visit
                e.m_value[name] = map.get(pkeyValue(e, fetchKeyPath)) || null;
            });
        }
        return this;
    }
    async fetchChild(name, param, { key, table, method = 'select', ...opts } = {}) {
        var _table = table || name;
        var ds = this.m_ds;
        util_1.default.assert(ds);
        var pk0 = ds.primaryKey(this.m_table);
        var { pkeyName, fetchKeyPath } = primaryKey(key || pk0);
        var ids_set = new Set();
        var ids = this.value
            .map((m) => pkeyValue(m, fetchKeyPath))
            .filter((e) => {
            if (e) {
                if (!ids_set.has(e)) {
                    ids_set.add(e);
                    return true;
                }
            }
            return false;
        });
        if (ids.length) {
            var collection = await ds.dao[_table][method]({ [pkeyName]: ids, limit: 0, ...param }, opts);
            var map = new Map();
            for (var m of collection.m_value) {
                var id = m.m_value[pkeyName];
                if (id) {
                    var col = map.get(id);
                    var ls;
                    if (col) {
                        ls = col.m_value;
                    }
                    else {
                        ls = [];
                        map.set(id, new Collection(ls, { table: _table, dataSource: ds }));
                    }
                    ls.push(m);
                }
            }
            this.value.forEach(e => {
                // TODO private visit
                var v = e.value;
                var col = map.get(pkeyValue(e, fetchKeyPath)) || new Collection([], { table: _table, dataSource: ds });
                v[name] = col;
                col.m_parent = e;
            });
        }
        return this;
    }
    toJSON() {
        if (this.m_parent) {
            return this.m_value;
        }
        else {
            return {
                index: this.m_index,
                total: this.total,
                length: this.m_value.length,
                value: this.m_value,
            };
        }
    }
}
exports.Collection = Collection;
