import { Result, Options as MysqlOptions } from './db';
import { Model, Collection, FetchOptions } from './model';
export interface Config {
    type?: string;
    redis?: Dict;
    original?: string;
    db?: MysqlOptions;
}
export declare const defaultConfig: Config;
export interface Options {
    where?: string;
    cacheTime?: number;
}
export interface QueryParams {
    limit?: number | number[];
    group?: string | string[] | Dict<string>;
    order?: string | string[] | Dict<string>;
    [prop: string]: any;
}
export declare type FetchParams = [string, // table name
QueryParams?, // params
FetchOptions?];
export declare type FetchParamsMix = FetchOptions | string;
export interface Params extends QueryParams {
    afterFetch?: FetchParamsMix[];
    fetchTotal?: boolean;
    onlyFetchTotal?: boolean;
}
export interface DataSource {
    map: SqlMap;
    readonly dao: DataAccessObject;
    primaryKey(table: string): string;
    get(name: string, param?: Params, opts?: Options): Promise<Model | null>;
    gets(name: string, param?: Params, opts?: Options): Promise<Collection>;
    post(name: string, param?: Params, opts?: Options): Promise<Result>;
    exec(name: string, param?: Params, opts?: Options): Promise<Result[]>;
}
export interface DataAccessMethod {
    <T = Collection | Result>(param?: Params, options?: Options): Promise<T>;
    exec(param?: Params, options?: Options): Promise<Result[]>;
    get(param?: Params, options?: Options): Promise<Model | null>;
}
declare type MethodType = string;
interface MethodsInfo {
    [method: string]: MethodType;
}
interface TablesInfo {
    [table: string]: MethodsInfo;
}
export declare class DataAccessShortcuts extends Proxy<Dict<DataAccessMethod>> {
    constructor(ds: DataSource, table: string, info: MethodsInfo);
    [method: string]: DataAccessMethod;
}
export declare class DataAccessObject extends Proxy<Dict<DataAccessShortcuts>> {
    constructor(ds: DataSource, info: TablesInfo);
    [table: string]: DataAccessShortcuts;
}
export interface Cache {
    get(key: string): Promise<Result[] | null>;
    set(key: string, data: Result[], cacheTime?: number): Promise<boolean>;
    remove(key: string): Promise<boolean>;
    close(): void;
}
export declare class LocalCache implements Cache {
    private m_host;
    private m_cache;
    private m_tntervalid;
    constructor(host: SqlMap);
    get(key: string): Promise<Result[] | null>;
    set(key: string, data: Result[], cacheTime?: number): Promise<boolean>;
    remove(key: string): Promise<boolean>;
    _ClearTimeout(): void;
    close(): void;
}
export declare class SqlMap implements DataSource {
    private m_original_mapinfo;
    private m_tables;
    private m_cache;
    readonly config: Config;
    readonly tablesInfo: TablesInfo;
    readonly map: SqlMap;
    /**
     * @field {Cache} is use cache
     */
    get cache(): Cache;
    set cache(value: Cache);
    /**
     * original xml base path
     */
    get original(): string;
    get type(): string;
    readonly dao: DataAccessObject;
    /**
     * @constructor
     * @arg [conf] {Object} Do not pass use center server config
     */
    constructor(conf?: Config);
    primaryKey(table: string): any;
    /**
     * @func get(name, param)
     */
    get(name: string, param?: Params, opts?: Options): Promise<Model<Dict<any>> | null>;
    /**
     * @func gets(name, param)
     */
    gets(name: string, param?: Params, opts?: Options): Promise<Collection<Dict<any>>>;
    /**
     * @func post(name, param)
     */
    post(name: string, param?: Params, opts?: Options): Promise<Result>;
    /**
     * @func query(name, param, cb)
     */
    exec(name: string, param?: Params, opts?: Options): Promise<Result[]>;
    /**
        * start transaction
        * @return {Transaction}
        */
    transaction<R>(cb: (ds: DataSource, dao: DataAccessObject) => Promise<R>): Promise<R>;
}
declare const _default: {
    SqlMap: typeof SqlMap;
    /**
     * @func setShared
     */
    setShared: (sqlmap: SqlMap) => void;
    /**
        * get default dao
        * @return {SqlMap}
        * @static
        */
    readonly shared: SqlMap | null;
};
export default _default;
